import import_declare_test

import os
import sys
import time
import datetime

import modinput_wrapper.base_modinput
from solnlib.packages.splunklib import modularinput as smi



import input_module_sfdc_object as input_module


'''
    Do not edit this file!!!
    This file is generated by Add-on builder automatically.
    Add your modular input logic to file input_module_sfdc_object.py
'''
class ModInputsfdc_object(modinput_wrapper.base_modinput.BaseModInput):

    def __init__(self):
        if 'use_single_instance_mode' in dir(input_module):
            use_single_instance = input_module.use_single_instance_mode()
        else:
            use_single_instance = False
        super(ModInputsfdc_object, self).__init__("splunk_ta_salesforce", "sfdc_object", use_single_instance)
        self.global_checkbox_fields = None

    def get_scheme(self):
        """overloaded splunklib modularinput method"""
        scheme = super(ModInputsfdc_object, self).get_scheme()
        scheme.title = ("Salesforce Object")
        scheme.description = ("")
        scheme.use_external_validation = True
        scheme.streaming_mode_xml = True

        scheme.add_argument(smi.Argument("name", title="Name",
                                         description="",
                                         required_on_create=True))

        """
        For customized inputs, hard code the arguments here to hide argument detail from users.
        For other input types, arguments should be get from input_module. Defining new input types could be easier.
        """
        scheme.add_argument(smi.Argument("account", title="Salesforce Account",
                                         description="",
                                         required_on_create=True,
                                         required_on_edit=False))
        scheme.add_argument(smi.Argument("object", title="Object",
                                         description="The name of the object to query for.",
                                         required_on_create=True,
                                         required_on_edit=False))
        scheme.add_argument(smi.Argument("object_fields", title="Object Fields",
                                         description="Object fields from which to collect data. Delimit multiple fields using comma (,).",
                                         required_on_create=True,
                                         required_on_edit=False))
        scheme.add_argument(smi.Argument("order_by", title="Order By",
                                         description="The datetime field by which to query results in ascending order for indexing.",
                                         required_on_create=True,
                                         required_on_edit=False))
        scheme.add_argument(smi.Argument("start_date", title="Query Start Date",
                                         description="The datetime after which to query and index records, in this format: \"YYYY-MM-DDThh:mm:ss.000z\".Defaults to 90 days earlier from now.",
                                         required_on_create=False,
                                         required_on_edit=False))
        scheme.add_argument(smi.Argument("limit", title="Limit",
                                         description="The maximum number of results returned by the query.",
                                         required_on_create=False,
                                         required_on_edit=False)),
        scheme.add_argument(smi.Argument("token", title="token",
                                         description="Deprecated field",
                                         required_on_create=False,
                                         required_on_edit=False)),
        scheme.add_argument(smi.Argument("endpoint", title="endpoint",
                                         description="Deprecated field",
                                         required_on_create=False,
                                         required_on_edit=False))
        return scheme

    def get_app_name(self):
        return "Splunk_TA_salesforce"

    def validate_input(self, definition):
        """validate the input stanza"""
        input_module.validate_input(self, definition)

    def collect_events(self, ew):
        """write out the events"""
        input_module.collect_events(self, ew)

    def get_account_fields(self):
        account_fields = []
        account_fields.append("account")
        return account_fields

    def get_checkbox_fields(self):
        checkbox_fields = []
        return checkbox_fields

    def get_global_checkbox_fields(self):
        if self.global_checkbox_fields is None:
            checkbox_fields = []
            customized_settings = {u'code': u'# encoding = utf-8\nimport splunk_ta_salesforce_declare\n\nimport logging\n\nimport sfdc_common as common\nfrom splunktaucclib.rest_handler import util\n\nutil.remove_http_proxy_env_vars()\n\n_DEFAULT_START_DATE = 90\n\n\ndef validate_input(helper, definition):\n    # Do not validate input because we cannot get all fields in input sometimes.\n    # For instance, if we add a stanza to inputs.conf, and one of the fields is\n    # raw text and need to encrypted, when modular input process start, it will\n    # read input through UCC and UCC will auto-encrypt this field. The problem is\n    # UCC will only submit this field, and then Splunk validation triggered. Only\n    # one field passed here.\n    pass\n\n\ndef _format_query(task):\n    """Build and quote the query string"""\n    task.add_preprocess_handler(\n        \'build_query\',\n        [\'{{is_greater_than}}\', \'{{object}}\', \'{{object_fields}}\', \'{{order_by}}\', \'{{limit}}\', \'{{start_date}}\'],\n        \'query_string\'\n    )\n    task.add_preprocess_handler(\'log\', [logging.DEBUG, \'Query SOQL={{query_string}}\'])\n    task.add_preprocess_handler(\'quote\', [\'{{query_string}}\'], \'query_string\')\n\n\ndef _fix_source_and_sourcetype(task):\n    """Fix source to sfdc_object://<object> and sourcetype to sfdc:<object>"""\n    task.add_postprocess_handler(\'set_var\', [\'sfdc_object://{{object}}\'], \'source\')\n    task.add_postprocess_handler(\'set_var\', [\'sfdc:{{object.lower()}}\'], \'sourcetype\')\n\n\ndef _stream_events(task):\n    # Add timestamp for each record\n    task.add_postprocess_handler(\n        \'convert_records_to_events\',\n        [\'{{records}}\', \'{{order_by}}\', \'{{index}}\', \'{{host}}\', \'{{source}}\', \'{{sourcetype}}\'],\n        \'splunk_events\'\n    )\n    task.add_postprocess_handler(\'std_output\', [\'{{splunk_events}}\'])\n    task.add_postprocess_handler(\'log\', [logging.DEBUG, \'{{records|count}} events collected\'])\n\n\ndef _configure_checkpoint(task):\n    task.configure_checkpoint(\n        name=\'{{name}}\',\n        content={\n            \'start_date\': \'{{start_date}}\',\n            \'is_greater_than\': \'{{is_greater_than}}\'\n        }\n    )\n\n\ndef list_objects(task_config, meta_config):\n    task = common.get_sfdc_task_template(\'ListRecords\', task_config, meta_config)\n    task.set_iteration_count(0)\n    _configure_checkpoint(task)\n    common.check_login_result(task)\n    _fix_source_and_sourcetype(task)\n\n    task.add_preprocess_handler(\'exit_if_true\', ["{{finished and finished.lower() == \'true\'}}"])\n\n    _format_query(task)\n\n    task.add_postprocess_handler(\'json_path\', [\'{{__response__.body}}\', \'records\'], \'records\')\n    task.add_postprocess_handler(\'json_path\', [\'{{records}}\', \'[-1].{{order_by}}\'], \'new_start_date\')\n    task.add_postprocess_handler(\'set_var\', [\'{{not records}}\'], \'finished\')\n\n    # Filter records which timestamp is not the last timestamp\n    task.add_postprocess_handler(\n        \'filter_records_before_date\',\n        [\'{{is_greater_than}}\', \'{{records}}\', \'{{order_by}}\', \'{{new_start_date}}\'], \'records\'\n    )\n    _stream_events(task)\n    task.add_postprocess_handler(\n        \'set_var\',\n        ["{{false if is_greater_than.lower() == \'true\' and finished.lower() == \'false\' else true}}"],\n        \'is_greater_than\'\n    )\n    task.add_postprocess_handler(\'set_var\', [\'{{new_start_date or start_date}}\'], \'start_date\')\n    return task\n\n\ndef collect_events(helper, ew):\n    """Collect events"""\n    stanza_name = helper.get_input_stanza_names()\n    logger = common.setup_logger(stanza_name, helper.get_log_level())\n    logger.info(\'Collecting events started.\')\n\n    task_config = helper.get_input_stanza(stanza_name)\n    if not task_config.get(\'account\'):\n        logger.warning(\'Salesforce account is not configured fully. Add-on is going to exit.\')\n        return\n\n    meta_config = helper._input_definition.metadata\n    meta_config[\'checkpoint_dir\'] = common.reset_checkpoint_dir(\n        meta_config[\'checkpoint_dir\'], task_config[\'name\'], logger\n    )\n    # Fix start date and limit if not filled or invalid\n    start_date = common.fix_start_date(\n        task_config.get(\'start_date\'), _DEFAULT_START_DATE, logger\n    )\n    limit = common.fix_limit(task_config.get(\'limit\'), logger)\n\n    task_config.update({\n        \'appname\': helper.get_app_name(),\n        \'stanza_name\': stanza_name,\n        \'start_date\': start_date,\n        \'limit\': limit,\n        \'is_greater_than\': \'true\',\n    })\n    tasks = (common.login_sfdc(), list_objects(task_config, meta_config))\n    common.run_tasks(tasks, ctx=task_config, proxy=helper.proxy)\n\n    logger.info(\'Collecting events finished.\')\n', u'parameters': [{u'required': True, u'possible_values': [], u'label': u'Salesforce Account', u'type': u'global_account', u'default_value': u'', u'format_type': u'global_account', u'placeholder': u'', u'value': u'', u'name': u'account', u'help_string': u''}, {u'required': True, u'possible_values': [{u'label': u'Production', u'value': u'login.salesforce.com'}, {u'label': u'Sandbox', u'value': u'test.salesforce.com'}], u'label': u'Salesforce Environment', u'type': u'dropdownlist', u'default_value': u'', u'format_type': u'dropdownlist', u'placeholder': u'', u'value': u'', u'name': u'endpoint', u'help_string': u''}, {u'required': False, u'type': u'password', u'label': u'Security Token', u'value': u'', u'default_value': u'', u'format_type': u'password', u'help_string': u'Enter the Salesforce security token.', u'name': u'token', u'placeholder': u''}, {u'required': True, u'type': u'text', u'label': u'Object', u'value': u'', u'default_value': u'', u'format_type': u'text', u'help_string': u'The name of the object to query for.', u'name': u'object', u'placeholder': u''}, {u'required': True, u'type': u'text', u'label': u'Object Fields', u'value': u'', u'default_value': u'', u'format_type': u'text', u'help_string': u'Object fields from which to collect data. Delimit multiple fields using comma (,).', u'name': u'object_fields', u'placeholder': u''}, {u'required': True, u'type': u'text', u'label': u'Order By', u'value': u'LastModifiedDate', u'default_value': u'LastModifiedDate', u'format_type': u'text', u'help_string': u'The datetime field by which to query results in ascending order for indexing.', u'name': u'order_by', u'placeholder': u'LastModifiedDate'}, {u'required': False, u'type': u'text', u'label': u'Query Start Date', u'value': u'', u'default_value': u'', u'format_type': u'text', u'help_string': u'The datetime after which to query and index records, in this format: "YYYY-MM-DDThh:mm:ss.000z".\nDefaults to 90 days earlier from now.', u'name': u'start_date', u'placeholder': u''}, {u'required': False, u'type': u'text', u'label': u'Limit', u'value': u'1000', u'default_value': u'1000', u'format_type': u'text', u'help_string': u'The maximum number of results returned by the query.', u'name': u'limit', u'placeholder': u'1000'}], 'sourcetype': u'sfdc:object', u'data_inputs_options': [{u'description': u'', u'possible_values': [], u'type': u'customized_var', u'required_on_create': True, u'format_type': u'global_account', u'name': u'account', u'title': u'Salesforce Account', u'placeholder': u'', u'required_on_edit': False, u'default_value': u''}, {u'description': u'', u'possible_values': [{u'label': u'Production', u'value': u'login.salesforce.com'}, {u'label': u'Sandbox', u'value': u'test.salesforce.com'}], u'type': u'customized_var', u'required_on_create': True, u'format_type': u'dropdownlist', u'name': u'endpoint', u'title': u'Salesforce Environment', u'placeholder': u'', u'required_on_edit': False, u'default_value': u''}, {u'description': u'Enter the Salesforce security token.', u'type': u'customized_var', u'required_on_create': False, u'format_type': u'password', u'required_on_edit': False, u'title': u'Security Token', u'placeholder': u'', u'name': u'token', u'default_value': u''}, {u'description': u'The name of the object to query for.', u'type': u'customized_var', u'required_on_create': True, u'format_type': u'text', u'required_on_edit': False, u'title': u'Object', u'placeholder': u'', u'name': u'object', u'default_value': u''}, {u'description': u'Object fields from which to collect data. Delimit multiple fields using comma (,).', u'type': u'customized_var', u'required_on_create': True, u'format_type': u'text', u'required_on_edit': False, u'title': u'Object Fields', u'placeholder': u'', u'name': u'object_fields', u'default_value': u''}, {u'description': u'The datetime field by which to query results in ascending order for indexing.', u'type': u'customized_var', u'required_on_create': True, u'format_type': u'text', u'required_on_edit': False, u'title': u'Order By', u'placeholder': u'LastModifiedDate', u'name': u'order_by', u'default_value': u'LastModifiedDate'}, {u'description': u'The datetime after which to query and index records, in this format: "YYYY-MM-DDThh:mm:ss.000z".\nDefaults to 90 days earlier from now.', u'type': u'customized_var', u'required_on_create': False, u'format_type': u'text', u'required_on_edit': False, u'title': u'Query Start Date', u'placeholder': u'', u'name': u'start_date', u'default_value': u''}, {u'description': u'The maximum number of results returned by the query.', u'type': u'customized_var', u'required_on_create': False, u'format_type': u'text', u'required_on_edit': False, u'title': u'Limit', u'placeholder': u'1000', u'name': u'limit', u'default_value': u'1000'}], 'interval': u'120', 'streaming_mode_xml': True, u'is_loaded': True, u'title': u'Salesforce Object', u'description': u'', u'type': u'customized', 'use_external_validation': True, 'index': u'default', u'customized_options': [{u'value': u'', u'name': u'account'}, {u'value': u'', u'name': u'endpoint'}, {u'value': u'', u'name': u'token'}, {u'value': u'', u'name': u'object'}, {u'value': u'', u'name': u'object_fields'}, {u'value': u'LastModifiedDate', u'name': u'order_by'}, {u'value': u'', u'name': u'start_date'}, {u'value': u'1000', u'name': u'limit'}], u'sample_count': 0, u'uuid': u'0ca98b4834434221907903895bac3b53', u'name': u'sfdc_object'}.get('global_settings', {}).get('customized_settings', [])
            for global_var in customized_settings:
                if global_var.get('type', '') == 'checkbox':
                    checkbox_fields.append(global_var['name'])
            self.global_checkbox_fields = checkbox_fields
        return self.global_checkbox_fields

if __name__ == "__main__":
    exitcode = ModInputsfdc_object().run(sys.argv)
    sys.exit(exitcode)
